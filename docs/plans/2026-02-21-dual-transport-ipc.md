# Dual-Transport IPC Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace ad-hoc `invoke()` calls with a typed `#[command]` / `#[event]` macro system that works transparently over Tauri IPC (production) and WebSocket (browser/dev verification).

**Architecture:** A `pzql-macros` proc macro crate emits `#[tauri::command]` + `#[specta::specta]` + an `inventory::submit!` entry on every annotated function. At dev-server startup, `inventory::iter` auto-discovers all commands - zero per-command registration. TypeScript bindings are auto-generated by tauri-specta; a WS-backed twin is 1 line per command, TypeScript-enforced so you can't forget. `ipc.ts` picks the right transport at runtime based on `window.__TAURI_INTERNALS__`.

**Tech Stack:** Rust proc macros (`syn`, `quote`, `proc-macro2`), `inventory` crate, `tauri-specta` v2, `specta` v2, `axum` + `tokio` (dev-server), `trybuild` + `insta` (macro tests), TypeScript, Playwright (browser verification).

---

## Structure after this plan

```
src-tauri/
  Cargo.toml             # workspace root
  crates/
    pzql-ipc/            # shared IPC types (WsCommandEntry etc.)
      Cargo.toml
      src/lib.rs
    pzql-macros/         # proc macros: #[command], #[event]
      Cargo.toml
      src/
        lib.rs
        command.rs
        event.rs
      tests/             # trybuild compile tests
        ui/
          ok_basic_command.rs
          ok_async_command.rs
          ok_basic_event.rs
          fail_missing_serialize.rs
  src/
    lib.rs               # Tauri app setup, register_commands![]
    main.rs
    dev_server/          # #[cfg(feature = "dev-server")]
      mod.rs
      server.rs
src/
  bindings.ts            # AUTO-GENERATED - never edit
  ws-bindings.ts         # 1 line per command, TypeScript-enforced
  ws-client.ts           # WebSocket transport - written once
  ipc.ts                 # transport bridge - written once
```

---

## Task 1: Restructure src-tauri as a Cargo workspace

**Files:**
- Modify: `src-tauri/Cargo.toml`
- Create: `src-tauri/crates/pzql-ipc/Cargo.toml`
- Create: `src-tauri/crates/pzql-ipc/src/lib.rs`

**Step 1: Convert Cargo.toml to a workspace**

Replace the entire `src-tauri/Cargo.toml` with:

```toml
[workspace]
members = [".", "crates/pzql-ipc", "crates/pzql-macros"]
resolver = "2"

[package]
name = "pzql"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

[lib]
name = "pzql_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
pzql-ipc = { path = "crates/pzql-ipc" }
pzql-macros = { path = "crates/pzql-macros" }
inventory = "0.3"

[features]
dev-server = ["dep:axum", "dep:tokio"]

[dependencies.axum]
version = "0.8"
features = ["ws"]
optional = true

[dependencies.tokio]
version = "1"
features = ["full"]
optional = true
```

**Step 2: Create pzql-ipc crate**

```
mkdir -p src-tauri/crates/pzql-ipc/src
```

`src-tauri/crates/pzql-ipc/Cargo.toml`:
```toml
[package]
name = "pzql-ipc"
version = "0.1.0"
edition = "2021"

[dependencies]
inventory = "0.3"
serde_json = "1"
```

`src-tauri/crates/pzql-ipc/src/lib.rs`:
```rust
use std::future::Future;
use std::pin::Pin;
use serde_json::Value;

pub type BoxFuture<T> = Pin<Box<dyn Future<Output = T> + Send + 'static>>;
pub type CommandResult = Result<Value, Value>;

pub struct WsCommandEntry {
    pub name: &'static str,
    pub handler: fn(Value) -> BoxFuture<CommandResult>,
}

inventory::collect!(WsCommandEntry);

pub struct WsEventEntry {
    pub name: &'static str,
}

inventory::collect!(WsEventEntry);
```

**Step 3: Verify the workspace compiles**

```sh
cd src-tauri && cargo check
```

Expected: no errors.

**Step 4: Commit**

```sh
git add src-tauri/Cargo.toml src-tauri/crates/
/commit
```

---

## Task 2: Create pzql-macros crate skeleton

**Files:**
- Create: `src-tauri/crates/pzql-macros/Cargo.toml`
- Create: `src-tauri/crates/pzql-macros/src/lib.rs`

**Step 1: Create Cargo.toml**

`src-tauri/crates/pzql-macros/Cargo.toml`:
```toml
[package]
name = "pzql-macros"
version = "0.1.0"
edition = "2021"

[lib]
proc-macro = true

[dependencies]
proc-macro2 = "1"
quote = "1"
syn = { version = "2", features = ["full"] }

[dev-dependencies]
trybuild = { version = "1", features = ["diff"] }
insta = "1"
```

**Step 2: Create lib.rs skeleton**

`src-tauri/crates/pzql-macros/src/lib.rs`:
```rust
mod command;
mod event;

use proc_macro::TokenStream;

#[proc_macro_attribute]
pub fn command(args: TokenStream, input: TokenStream) -> TokenStream {
    command::expand(args.into(), input.into())
        .unwrap_or_else(|e| e.to_compile_error())
        .into()
}

#[proc_macro_attribute]
pub fn event(_args: TokenStream, input: TokenStream) -> TokenStream {
    event::expand(input.into())
        .unwrap_or_else(|e| e.to_compile_error())
        .into()
}
```

Create empty stubs:

`src-tauri/crates/pzql-macros/src/command.rs`:
```rust
use proc_macro2::TokenStream;
use syn::Error;

pub fn expand(_args: TokenStream, input: TokenStream) -> Result<TokenStream, Error> {
    Ok(input) // passthrough for now
}
```

`src-tauri/crates/pzql-macros/src/event.rs`:
```rust
use proc_macro2::TokenStream;
use syn::Error;

pub fn expand(input: TokenStream) -> Result<TokenStream, Error> {
    Ok(input) // passthrough for now
}
```

**Step 3: Verify**

```sh
cd src-tauri && cargo check
```

Expected: no errors.

**Step 4: Commit**

```sh
/commit
```

---

## Task 3: Implement #[command] macro

The macro transforms:
```rust
#[command]
async fn greet(name: String) -> String { ... }
```

Into:
```rust
#[tauri::command]
#[specta::specta]
async fn greet(name: String) -> String { ... }

#[derive(serde::Deserialize)]
struct __GreetArgs { name: String }

inventory::submit! {
    pzql_ipc::WsCommandEntry {
        name: "greet",
        handler: |args| Box::pin(async move {
            let a: __GreetArgs = serde_json::from_value(args)
                .map_err(|e| serde_json::json!({"message": e.to_string()}))?;
            let result = greet(a.name).await;
            serde_json::to_value(result)
                .map_err(|e| serde_json::json!({"message": e.to_string()}))
        }),
    }
}
```

**Files:**
- Modify: `src-tauri/crates/pzql-macros/src/command.rs`
- Add to pzql-macros Cargo.toml: `heck = "0.5"` (for snake_case → PascalCase)

**Step 1: Add heck dependency**

In `src-tauri/crates/pzql-macros/Cargo.toml` under `[dependencies]`:
```toml
heck = "0.5"
```

**Step 2: Implement expand()**

Replace `src-tauri/crates/pzql-macros/src/command.rs` with:

```rust
use heck::ToPascalCase;
use proc_macro2::{Span, TokenStream};
use quote::quote;
use syn::{
    Error, FnArg, Ident, ItemFn, Pat, PatType, Result, ReturnType, Type, parse2,
};

pub fn expand(_args: TokenStream, input: TokenStream) -> Result<TokenStream, Error> {
    let func: ItemFn = parse2(input)?;
    let fn_name = &func.sig.ident;
    let fn_name_str = fn_name.to_string();

    // Collect plain (non-State, non-AppHandle) parameters
    let plain_params: Vec<(&Ident, &Type)> = func
        .sig
        .inputs
        .iter()
        .filter_map(|arg| match arg {
            FnArg::Typed(PatType { pat, ty, .. }) => {
                // Skip tauri::State<T> and tauri::AppHandle injected args
                let ty_str = quote!(#ty).to_string();
                if ty_str.contains("State") || ty_str.contains("AppHandle") {
                    return None;
                }
                match pat.as_ref() {
                    Pat::Ident(p) => Some((&p.ident, ty.as_ref())),
                    _ => None,
                }
            }
            FnArg::Receiver(_) => None,
        })
        .collect();

    // Build args struct name: __GreetArgs
    let struct_name = Ident::new(
        &format!("__{}", fn_name_str.to_pascal_case() + "Args"),
        Span::call_site(),
    );

    let field_names: Vec<&Ident> = plain_params.iter().map(|(n, _)| *n).collect();
    let field_types: Vec<&Type> = plain_params.iter().map(|(_, t)| *t).collect();
    let field_names2 = field_names.clone();

    // Determine if fn is async
    let is_async = func.sig.asyncness.is_some();
    let call = if is_async {
        quote! { #fn_name(#(a.#field_names2),*).await }
    } else {
        quote! { #fn_name(#(a.#field_names2),*) }
    };

    // Preserve the return type for type inference
    let _ret = &func.sig.output;

    Ok(quote! {
        #[tauri::command]
        #[specta::specta]
        #func

        #[derive(serde::Deserialize)]
        #[allow(non_camel_case_types)]
        struct #struct_name {
            #(#field_names: #field_types,)*
        }

        inventory::submit! {
            pzql_ipc::WsCommandEntry {
                name: #fn_name_str,
                handler: |args| Box::pin(async move {
                    let a: #struct_name = serde_json::from_value(args)
                        .map_err(|e| serde_json::json!({"message": e.to_string()}))?;
                    let result = #call;
                    serde_json::to_value(result)
                        .map_err(|e| serde_json::json!({"message": e.to_string()}))
                }),
            }
        }
    })
}
```

**Step 3: Add specta to pzql (main crate) dependencies**

In `src-tauri/Cargo.toml` under `[dependencies]`:
```toml
specta = "2"
tauri-specta = { version = "2", features = ["derive", "typescript"] }
```

**Step 4: Verify compile**

```sh
cd src-tauri && cargo check
```

Expected: no errors.

**Step 5: Commit**

```sh
/commit
```

---

## Task 4: Test #[command] macro with trybuild

**Files:**
- Create: `src-tauri/crates/pzql-macros/tests/macros.rs`
- Create: `src-tauri/crates/pzql-macros/tests/ui/ok_sync_command.rs`
- Create: `src-tauri/crates/pzql-macros/tests/ui/ok_async_command.rs`
- Create: `src-tauri/crates/pzql-macros/tests/ui/ok_multi_arg_command.rs`

**Step 1: Write the trybuild test runner**

`src-tauri/crates/pzql-macros/tests/macros.rs`:
```rust
#[test]
fn ui() {
    let t = trybuild::TestCases::new();
    t.pass("tests/ui/ok_*.rs");
    t.compile_fail("tests/ui/fail_*.rs");
}
```

**Step 2: Write passing test cases**

`src-tauri/crates/pzql-macros/tests/ui/ok_sync_command.rs`:
```rust
use pzql_macros::command;

#[command]
fn greet(name: String) -> String {
    format!("Hello, {}!", name)
}

fn main() {}
```

`src-tauri/crates/pzql-macros/tests/ui/ok_async_command.rs`:
```rust
use pzql_macros::command;

#[command]
async fn fetch_data(id: u32) -> String {
    format!("data for {}", id)
}

fn main() {}
```

`src-tauri/crates/pzql-macros/tests/ui/ok_multi_arg_command.rs`:
```rust
use pzql_macros::command;

#[command]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {}
```

**Step 3: Run tests**

```sh
cd src-tauri && cargo test -p pzql-macros
```

Expected: all pass.

**Step 4: Commit**

```sh
/commit
```

---

## Task 5: Implement #[event] macro

The macro transforms:
```rust
#[event]
#[derive(Serialize, Deserialize, specta::Type)]
struct FileChanged { path: String }
```

Into the original struct plus a typed emit helper:
```rust
#[derive(Serialize, Deserialize, specta::Type)]
struct FileChanged { path: String }

impl FileChanged {
    pub fn emit(handle: &impl tauri::Manager<tauri::Wry>) -> tauri::Result<()> {
        // In normal mode: handle.emit("file_changed", self)
        // In dev-server mode: push via WS (handled by the dev server's event channel)
        handle.emit("file_changed", &self)
    }
}

inventory::submit! {
    pzql_ipc::WsEventEntry { name: "file_changed" }
}
```

**Files:**
- Modify: `src-tauri/crates/pzql-macros/src/event.rs`

**Step 1: Implement expand()**

Replace `src-tauri/crates/pzql-macros/src/event.rs` with:

```rust
use heck::ToSnakeCase;
use proc_macro2::TokenStream;
use quote::quote;
use syn::{Error, ItemStruct, Result, parse2};

pub fn expand(input: TokenStream) -> Result<TokenStream, Error> {
    let struct_def: ItemStruct = parse2(input.clone())?;
    let struct_name = &struct_def.ident;
    let event_name = struct_name.to_string().to_snake_case();

    Ok(quote! {
        #struct_def

        impl #struct_name {
            pub fn emit(&self, handle: &impl ::tauri::Manager<::tauri::Wry>) -> ::tauri::Result<()> {
                handle.emit(#event_name, self)
            }
        }

        inventory::submit! {
            pzql_ipc::WsEventEntry { name: #event_name }
        }
    })
}
```

**Step 2: Write passing test cases**

`src-tauri/crates/pzql-macros/tests/ui/ok_basic_event.rs`:
```rust
use pzql_macros::event;
use serde::{Deserialize, Serialize};

#[event]
#[derive(Serialize, Deserialize, specta::Type)]
struct FileChanged {
    path: String,
    kind: String,
}

fn main() {}
```

**Step 3: Run tests**

```sh
cd src-tauri && cargo test -p pzql-macros
```

Expected: all pass.

**Step 4: Commit**

```sh
/commit
```

---

## Task 6: Implement the dev-server (WebSocket)

The dev-server reads all `WsCommandEntry` items from inventory and dispatches incoming WebSocket messages to the correct handler.

**Protocol:**

Request (frontend → server):
```json
{ "id": 1, "cmd": "greet", "args": { "name": "Alice" } }
```

Response (server → frontend):
```json
{ "id": 1, "result": "Hello, Alice!", "error": null }
```

Event push (server → frontend):
```json
{ "event": "file_changed", "payload": { "path": "/foo", "kind": "modify" } }
```

**Files:**
- Create: `src-tauri/src/dev_server/mod.rs`
- Create: `src-tauri/src/dev_server/server.rs`
- Modify: `src-tauri/src/lib.rs`

**Step 1: Create dev_server/mod.rs**

`src-tauri/src/dev_server/mod.rs`:
```rust
pub mod server;
pub use server::run;
```

**Step 2: Create dev_server/server.rs**

`src-tauri/src/dev_server/server.rs`:
```rust
use axum::{
    Router,
    extract::ws::{Message, WebSocket, WebSocketUpgrade},
    response::IntoResponse,
    routing::get,
};
use futures_util::{SinkExt, StreamExt};
use inventory;
use pzql_ipc::WsCommandEntry;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;
use tokio::net::TcpListener;

const PORT: u16 = 1421;

#[derive(Deserialize)]
struct WsRequest {
    id: u64,
    cmd: String,
    args: Value,
}

#[derive(Serialize)]
struct WsResponse {
    id: u64,
    result: Option<Value>,
    error: Option<Value>,
}

pub async fn run() {
    let app = Router::new().route("/ws", get(ws_handler));
    let listener = TcpListener::bind(("127.0.0.1", PORT)).await.unwrap();
    println!("dev-server listening on ws://127.0.0.1:{PORT}");
    axum::serve(listener, app).await.unwrap();
}

async fn ws_handler(ws: WebSocketUpgrade) -> impl IntoResponse {
    ws.on_upgrade(handle_socket)
}

async fn handle_socket(socket: WebSocket) {
    let handlers: HashMap<&str, _> = inventory::iter::<WsCommandEntry>()
        .map(|e| (e.name, e.handler))
        .collect();

    let (mut sender, mut receiver) = socket.split();

    while let Some(Ok(Message::Text(text))) = receiver.next().await {
        let req: WsRequest = match serde_json::from_str(&text) {
            Ok(r) => r,
            Err(e) => {
                eprintln!("bad ws message: {e}");
                continue;
            }
        };

        let response = match handlers.get(req.cmd.as_str()) {
            Some(handler) => match handler(req.args).await {
                Ok(result) => WsResponse { id: req.id, result: Some(result), error: None },
                Err(error) => WsResponse { id: req.id, result: None, error: Some(error) },
            },
            None => WsResponse {
                id: req.id,
                result: None,
                error: Some(serde_json::json!({ "message": format!("unknown command: {}", req.cmd) })),
            },
        };

        let _ = sender
            .send(Message::Text(serde_json::to_string(&response).unwrap().into()))
            .await;
    }
}
```

**Step 3: Add futures-util to dev-server dependencies**

In `src-tauri/Cargo.toml` update the dev-server feature section:
```toml
[dependencies.futures-util]
version = "0.3"
optional = true

[features]
dev-server = ["dep:axum", "dep:tokio", "dep:futures-util"]
```

**Step 4: Wire into lib.rs**

Replace `src-tauri/src/lib.rs` with:
```rust
#[cfg(feature = "dev-server")]
mod dev_server;

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    #[cfg(feature = "dev-server")]
    {
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(dev_server::run());
        return;
    }

    #[cfg(not(feature = "dev-server"))]
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .invoke_handler(tauri::generate_handler![greet])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

#[tauri::command]
fn greet(name: &str) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}
```

**Step 5: Verify compile**

```sh
cd src-tauri && cargo check --features dev-server
```

Expected: no errors.

**Step 6: Commit**

```sh
/commit
```

---

## Task 7: Convert greet to #[command] and verify end-to-end

**Files:**
- Modify: `src-tauri/src/lib.rs`
- Add: tauri-specta setup

**Step 1: Add tauri-specta to Cargo.toml**

In `src-tauri/Cargo.toml` under `[dependencies]`:
```toml
tauri-specta = { version = "2", features = ["derive", "typescript"] }
specta-typescript = "0.0.7"
```

**Step 2: Update lib.rs to use #[command] and tauri-specta**

```rust
use pzql_macros::command;
use tauri_specta::{collect_commands, Builder};

#[cfg(feature = "dev-server")]
mod dev_server;

#[command]
fn greet(name: String) -> String {
    format!("Hello, {}! You've been greeted from Rust!", name)
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    #[cfg(feature = "dev-server")]
    {
        let rt = tokio::runtime::Runtime::new().unwrap();
        rt.block_on(dev_server::run());
        return;
    }

    #[cfg(not(feature = "dev-server"))]
    {
        let builder = Builder::<tauri::Wry>::new().commands(collect_commands![greet]);

        // Generate bindings in dev mode
        #[cfg(debug_assertions)]
        builder
            .export(
                specta_typescript::Typescript::default()
                    .header("// AUTO-GENERATED - do not edit"),
                "../src/bindings.ts",
            )
            .expect("failed to export typescript bindings");

        tauri::Builder::default()
            .plugin(tauri_plugin_opener::init())
            .invoke_handler(builder.invoke_handler())
            .setup(move |app| {
                builder.mount_events(app);
                Ok(())
            })
            .run(tauri::generate_context!())
            .expect("error while running tauri application");
    }
}
```

**Step 3: Verify cargo check passes for both modes**

```sh
cd src-tauri && cargo check && cargo check --features dev-server
```

Expected: no errors in either mode.

**Step 4: Run tauri dev to generate bindings.ts**

```sh
bun run tauri dev
```

Wait for `src/bindings.ts` to be generated, then quit. Verify the file exists with a `greet` command entry.

**Step 5: Commit**

```sh
/commit
```

---

## Task 8: Write the TypeScript transport layer

**Files:**
- Create: `src/ws-client.ts`
- Create: `src/ws-bindings.ts`
- Create: `src/ipc.ts`
- Modify: `src/App.tsx`

**Step 1: Write ws-client.ts**

`src/ws-client.ts`:
```typescript
const WS_URL = "ws://127.0.0.1:1421/ws";

type PendingCall = {
  resolve: (value: unknown) => void;
  reject: (reason: unknown) => void;
};

const pending = new Map<number, PendingCall>();
const eventListeners = new Map<string, Set<(payload: unknown) => void>>();
let seq = 0;
let ws: WebSocket | null = null;

function getSocket(): WebSocket {
  if (ws && ws.readyState === WebSocket.OPEN) return ws;

  ws = new WebSocket(WS_URL);

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data as string);

    if (typeof msg.event === "string") {
      // Push event from Rust
      eventListeners.get(msg.event)?.forEach((cb) => cb(msg.payload));
      return;
    }

    const p = pending.get(msg.id);
    if (!p) return;
    pending.delete(msg.id);

    if (msg.error != null) {
      p.reject(msg.error);
    } else {
      p.resolve(msg.result);
    }
  };

  return ws;
}

export function wsInvoke<T>(
  cmd: string,
  args: Record<string, unknown> = {},
): Promise<T> {
  return new Promise((resolve, reject) => {
    const id = ++seq;
    pending.set(id, { resolve: resolve as (v: unknown) => void, reject });
    getSocket().send(JSON.stringify({ id, cmd, args }));
  });
}

export function wsListen<T>(
  event: string,
  cb: (payload: T) => void,
): () => void {
  if (!eventListeners.has(event)) {
    eventListeners.set(event, new Set());
  }
  const set = eventListeners.get(event)!;
  set.add(cb as (payload: unknown) => void);
  // Ensure socket is open so we receive pushes
  getSocket();
  return () => set.delete(cb as (payload: unknown) => void);
}
```

**Step 2: Write ws-bindings.ts**

This file mirrors the shape of the auto-generated `bindings.ts` but uses `wsInvoke` / `wsListen`. TypeScript enforces it stays in sync.

`src/ws-bindings.ts`:
```typescript
import type { commands as BoundCommands } from "./bindings";
import { wsInvoke } from "./ws-client";

// This must satisfy typeof BoundCommands. TypeScript errors if a command
// is in bindings.ts but missing here - you cannot forget.
export const wsCommands: typeof BoundCommands = {
  greet: (name: string) => wsInvoke<string>("greet", { name }),
};
```

**Step 3: Write ipc.ts**

`src/ipc.ts`:
```typescript
import { commands as tauriCommands } from "./bindings";
import { wsCommands } from "./ws-bindings";

const isTauri = "__TAURI_INTERNALS__" in window;

// All app code imports from here. Never import from bindings.ts directly.
export const commands = isTauri ? tauriCommands : wsCommands;
```

**Step 4: Update App.tsx to use ipc.ts**

In `src/App.tsx`, replace:
```typescript
import { invoke } from "@tauri-apps/api/core";
```
with:
```typescript
import { commands } from "./ipc";
```

And replace the `greet()` call:
```typescript
// before:
setGreetMsg(await invoke("greet", { name }));

// after:
setGreetMsg(await commands.greet(name));
```

**Step 5: Type-check**

```sh
bun run build
```

Expected: no TypeScript errors.

**Step 6: Commit**

```sh
/commit
```

---

## Task 9: End-to-end verification in dev-server mode

**Step 1: Start the dev-server**

Terminal 1:
```sh
cd src-tauri && cargo watch -x 'run --features dev-server'
```

Wait for: `dev-server listening on ws://127.0.0.1:1421`

Terminal 2:
```sh
bun run dev
```

Wait for: `Local: http://localhost:1420/`

**Step 2: Open Chrome and verify**

Open `http://localhost:1420` in Chrome (not the Tauri app).

Open DevTools console. Run:
```javascript
// Should NOT see __TAURI_INTERNALS__ - confirms browser mode
console.log("isTauri:", "__TAURI_INTERNALS__" in window); // false
```

**Step 3: Test the greet command**

Type a name in the input, click Greet. The response should appear: `Hello, [name]! You've been greeted from Rust!`

This confirms the WebSocket path through real Rust is working.

**Step 4: Verify in Tauri mode still works**

```sh
bun run tauri dev
```

Type a name, click Greet. Same result via Tauri IPC.

**Step 5: Commit**

```sh
/commit
```

---

## Task 10: Update CLAUDE.md

**Files:**
- Modify: `CLAUDE.md`

**Step 1: Add IPC section to CLAUDE.md**

Add after the "Architecture" section:

```markdown
## IPC: Commands and Events

All frontend-backend communication uses the dual-transport IPC layer. Never call `invoke()` or `emit()` directly.

### Adding a command (Rust → called by frontend)

1. Define the function with `#[command]` in `src-tauri/src/lib.rs` (or a commands module):
   ```rust
   use pzql_macros::command;

   #[command]
   async fn my_command(arg: String) -> Result<String, String> {
       Ok(format!("got: {arg}"))
   }
   ```
2. Add the function name to `collect_commands![]` in `lib.rs`:
   ```rust
   let builder = Builder::<tauri::Wry>::new()
       .commands(collect_commands![greet, my_command]);
   ```
3. Add one line to `src/ws-bindings.ts`:
   ```typescript
   export const wsCommands: typeof BoundCommands = {
       greet: ...,
       myCommand: (arg: string) => wsInvoke<string>("my_command", { arg }),
   };
   ```
4. Run `bun run tauri dev` once to regenerate `src/bindings.ts`.
5. All app code calls `commands.myCommand(arg)` via `src/ipc.ts`.

The `#[command]` macro auto-registers the command for the WebSocket dev-server via `inventory`. Step 2 is for Tauri IPC + TypeScript type generation. Step 3 is TypeScript-enforced - it won't compile if you forget.

### Adding an event (Rust → pushed to frontend)

1. Define the struct with `#[event]`:
   ```rust
   use pzql_macros::event;

   #[event]
   #[derive(Serialize, Deserialize, specta::Type)]
   struct MyEvent { field: String }
   ```
2. Emit it from Rust: `MyEvent { field: "value".into() }.emit(&app_handle)?;`
3. Run `bun run tauri dev` to regenerate `src/bindings.ts`.
4. Listen in TypeScript via `src/ipc.ts` (events bridge - see ws-client.ts for WS listeners).

### Dev verification mode

To run the full app (real Rust) in Chrome for visual verification:

```sh
# Terminal 1 - auto-recompiles on Rust changes
cd src-tauri && cargo watch -x 'run --features dev-server'

# Terminal 2
bun run dev

# Open http://localhost:1420 in Chrome
```

The frontend detects the absence of `window.__TAURI_INTERNALS__` and routes all commands over WebSocket to the Rust dev-server. Claude can then use Playwright or Peekaboo on Chrome to verify UI and backend behavior.

### Key files

| File | Edit? | Purpose |
|------|-------|---------|
| `src/bindings.ts` | Never | Auto-generated by tauri-specta |
| `src/ws-bindings.ts` | Per new command (1 line) | WS transport implementations |
| `src/ws-client.ts` | Never | WebSocket transport layer |
| `src/ipc.ts` | Never | Transport bridge |
```

**Step 2: Commit**

```sh
/commit
```

---

## Done

The system is live. Checklist for adding any future command:

1. `#[command]` on the Rust fn - WS dev-server is automatic
2. Add to `collect_commands![]` - Tauri IPC + TS types
3. One line in `ws-bindings.ts` - TypeScript enforces this, won't compile if missing
4. `bun run tauri dev` once to regenerate `bindings.ts`

Everything else - dispatch, serialization, transport selection, type checking - is handled by the infrastructure.
